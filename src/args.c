#include <getopt.h>

#include "args.h"

#define USAGE_STRING "hilrv"

static int8_t 
args_opt_error(struct args_data *in, enum args_operation update)
{
	if (in->operation != 0) {
		fprintf(stderr, "sspkg: error too many requested operations to passed, single target at time!\n");
		return -2;
	}
	in->operation = update;
	return 0;
}

int8_t
args_parse(int32_t argc, const char *argv[], struct args_data *in)
{
	int c;
	/* Disable output errors generated by getopt */
	opterr = 0;
	while ((c = getopt(argc, (char *const *)argv, USAGE_STRING)) != -1) {
		switch ((char)c) {
			case 'h': {
				return -2;
			}
			case 'i': {
				if (args_opt_error(in, ARGS_OPERATION_INSTALL) < 0) {
					return -2;
				}
				break;
			}
			case 'l': {
				args_msg_license();
				return -1;
			}
			case 'r': {
				if (args_opt_error(in, ARGS_OPERATION_REMOVE) < 0) {
					return -2;
				}
				break;
			}
			case 'v': {
				args_msg_version();
				return -1;
			}
			default: {
				break;
			}
		}
	}
	/* Check if a package is supplied. */
	if ((argc - optind) == 0) {
		fprintf(stderr, "sspkg: error please supply at least a single package to operate on!\n");
		return -2;
	}

	/* Check for a single operation that has been supplied. */
	if (in->operation == 0) {
		fprintf(stderr, "sspkg: error no package operation has been supplied, operation required!\n");
		return -2;
	}

	/* Create an array for all the packages to be installed. */
	in->pkgs_count = argc - optind;
	in->pkgs = (const char **)calloc(argc - optind, sizeof(*argv));

	/* Copy the memory. */
	memcpy(in->pkgs, argv + optind, sizeof(*in->pkgs) * in->pkgs_count);
	return 0;
}
void args_msg_help(void)
{
	fprintf(stdout, "sspkg: usage [-%s] [-h help] [-i install] [-l license] [-r remove] [-v version] [package].\n", USAGE_STRING);
}
void args_msg_version(void)
{

}
void args_msg_license(void)
{

}
